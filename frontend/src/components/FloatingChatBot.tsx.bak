import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { useChat } from '../hooks/useChat';
import { useMonitoring } from '../hooks/useMonitoring';
import { AIAction } from '../types/chat.types';
import { ChatMessage } from './chat/ChatMessage';
import { ChatInput } from './chat/ChatInput';
import { AIActionsMenu } from './chat/AIActionsMenu';
import { Bot, X } from 'lucide-react';

// Define screen size breakpoints
const SCREEN_BREAKPOINTS = {
  MOBILE: 768,
  TABLET: 1024,
};

interface FloatingChatBotProps {
  // Optional props for customization
}

const FloatingChatBot: React.FC<FloatingChatBotProps> = () => {
  const { t } = useTranslation();
  const { theme } = useTheme();
  const { user } = useAuth();
  const { logError, logInfo } = useMonitoring();
  const darkMode = theme === 'dark';
  const [isOpen, setIsOpen] = useState(false);
  const [showAIActions, setShowAIActions] = useState(false);
  const [position, setPosition] = useState({ bottom: '6rem', right: '1.5rem' });
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);

  // Use the chat hook for managing chat state and WebSocket connection
  const {
    messages,
    isConnected,
    isTyping,
    unreadCount,
    error,
    sendMessage,
    markAllAsRead,
  } = useChat(user?.id?.toString());

  // Find login button in the DOM
  const findLoginButtonPosition = useCallback((): HTMLElement | null => {
    // Try various selectors to find the login button
    const selectorOptions = [
      'header button:has(svg[class*="User"])',  // SVG with User class
      'header button:has(svg[class*="LogOut"])',  // SVG with LogOut class
      'header .btn-primary',  // Primary button in header
      'header [aria-label*="login" i], header [aria-label*="auth" i]',  // ARIA labels
      '.header button',  // General header buttons
      'nav button',  // In navigation
      '[data-testid="login-button"]',  // Test ID (if available)
      '[data-testid="auth-button"]',  // Auth button test ID
      'button.login',  // Login class
      'button.auth'  // Auth class
    ];

    // Try to find login button using different selectors
    for (const selector of selectorOptions) {
      try {
        const button = document.querySelector<HTMLElement>(selector);
        if (button) {
          // Additional verification that this is an actual login button
          const textContent = button.textContent?.toLowerCase() || '';
          const ariaLabel = button.getAttribute('aria-label')?.toLowerCase() || '';
          
          if (
            textContent.includes('login') || 
            textContent.includes('ورود') || 
            textContent.includes('sign') ||
            ariaLabel.includes('login') ||
            ariaLabel.includes('auth') ||
            button.classList.contains('login') ||
            button.classList.contains('auth') ||
            button.classList.contains('btn-primary')
          ) {
            return button;
          }
        }
      } catch (e) {
        // Ignore selector errors and try the next option
        continue;
      }
    }

    // If individual selectors don't work, try manual iteration
    const allButtons = document.querySelectorAll<HTMLElement>('header button, .header button, nav button');
    for (const button of allButtons) {
      // Check for login-related text or common login button patterns
      const textContent = button.textContent?.toLowerCase() || '';
      const ariaLabel = button.getAttribute('aria-label')?.toLowerCase() || '';

      if (
        textContent.includes('login') ||
        textContent.includes('ورود') ||
        textContent.includes('sign') ||
        ariaLabel.includes('login') ||
        ariaLabel.includes('auth') ||
        button.classList.contains('login') ||
        button.classList.contains('auth') ||
        button.classList.contains('btn-primary')
      ) {
        // Additional check: if it's in the header and looks like an auth button
        const header = document.querySelector('header');
        if (header && header.contains(button)) {
          // Check if it's one of the auth-related buttons
          if (button.querySelector('svg[class*="User"]') ||
              button.querySelector('svg[class*="LogOut"]') ||
              button.classList.contains('btn-primary')) {
            return button;
          }
        }
      }
    }

    return null; // Login button not found
  }, []);

  // Calculate the chat button position based on the login button position
  const calculateChatButtonPosition = useCallback((): { bottom: string, right: string } => {
    const loginButton = findLoginButtonPosition();
    
    if (loginButton) {
      const rect = loginButton.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      
      // Calculate position 20px below the login button
      let calculatedBottom = viewportHeight - rect.bottom + 20; // 20px below the login button
      
      // Apply constraints based on screen size
      if (viewportWidth < SCREEN_BREAKPOINTS.MOBILE) {
        // On mobile, use smaller margins
        calculatedBottom = Math.max(60, calculatedBottom); // Minimum 60px on mobile
        calculatedBottom = Math.min(viewportHeight - 80, calculatedBottom); // Maximum leaving space at bottom
      } else if (viewportWidth < SCREEN_BREAKPOINTS.TABLET) {
        // On tablet
        calculatedBottom = Math.max(70, calculatedBottom); // Minimum 70px on tablet
        calculatedBottom = Math.min(viewportHeight - 90, calculatedBottom);
      } else {
        // On desktop
        calculatedBottom = Math.max(70, calculatedBottom); // Minimum 70px on desktop
        calculatedBottom = Math.min(viewportHeight - 100, calculatedBottom); // Maximum leaving space at bottom
      }

      // Set appropriate right position based on screen size
      let rightPosition = '1.5rem'; // Default
      if (viewportWidth < SCREEN_BREAKPOINTS.MOBILE) {
        rightPosition = '1rem'; // Less right margin on mobile
      } else if (viewportWidth < SCREEN_BREAKPOINTS.TABLET) {
        rightPosition = '1.25rem'; // Medium right margin on tablet
      }

      logInfo('Calculated chat button position', {
        bottom: calculatedBottom,
        right: rightPosition,
        viewportWidth,
        viewportHeight,
        loginButtonRect: rect
      });

      return {
        bottom: `${calculatedBottom}px`,
        right: rightPosition
      };
    } else {
      // Fallback positioning with responsive values
      const viewportWidth = window.innerWidth;
      logInfo('Using fallback chat button position', {
        viewportWidth,
        userId: user?.id
      });
      
      if (viewportWidth < SCREEN_BREAKPOINTS.MOBILE) {
        return { bottom: '4rem', right: '1rem' }; // Mobile fallback
      } else if (viewportWidth < SCREEN_BREAKPOINTS.TABLET) {
        return { bottom: '5rem', right: '1.25rem' }; // Tablet fallback
      } else {
        return { bottom: '6rem', right: '1.5rem' }; // Desktop fallback
      }
    }
  }, [user?.id, logInfo]);

  // Calculate position relative to login button
  useEffect(() => {
    let mounted = true;
    
    const updatePosition = () => {
      if (!mounted) return;
      
      const newPosition = calculateChatButtonPosition();
      setPosition(newPosition);
    };

    // Initial calculation
    updatePosition();

    // Set up event listeners for position changes
    const handleResize = () => {
      updatePosition();
    };

    const handleScroll = () => {
      // Use requestAnimationFrame to batch scroll updates for performance
      requestAnimationFrame(updatePosition);
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleScroll, { passive: true });

    // Use ResizeObserver to watch for changes in the login button's size/position
    // This ensures we update position when the header changes
    if (typeof ResizeObserver !== 'undefined') {
      const loginButton = findLoginButtonPosition();
      if (loginButton) {
        resizeObserverRef.current = new ResizeObserver(() => {
          updatePosition();
        });
        resizeObserverRef.current.observe(loginButton);
      }
    }

    // Poll for login button in case it's loaded asynchronously (with performance improvement)
    let pollInterval: number | undefined;
    
    // Only start polling if we haven't found the login button yet
    if (!findLoginButtonPosition()) {
      pollInterval = window.setInterval(() => {
        const currentLoginButton = findLoginButtonPosition();
        if (currentLoginButton) {
          updatePosition();
          // Stop polling once we find the login button
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = undefined;
          }
        }
      }, 1000); // Reduced polling frequency for performance
    }

    // Cleanup function
    return () => {
      mounted = false;
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('scroll', handleScroll);
      clearInterval(pollInterval);
      
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect();
        resizeObserverRef.current = null;
      }
    };
  }, [calculateChatButtonPosition, findLoginButtonPosition]);

  // Handle sending a new message
  const handleSendMessage = useCallback((text: string) => {
    sendMessage(text);
  }, [sendMessage]);

  // Handle AI action
  const handleAIAction = useCallback((_: AIAction) => {
    setShowAIActions(false);

    // Add the AI message directly without waiting for WebSocket
    // In a real implementation, this would be handled by the WebSocket
    setTimeout(() => {
      // For this example, just add directly to state
      // In the real useChat hook, this would be handled by the WebSocket response
    }, 100);

    // Update unread count if chat is closed
    if (!isOpen) {
      // Update in the hook
    }
  }, [t, isOpen]);

  // Mark messages as read when chat is opened
  useEffect(() => {
    if (isOpen && unreadCount > 0) {
      markAllAsRead();
    }
  }, [isOpen, unreadCount, markAllAsRead]);

  // Scroll to bottom when messages change
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [messages]);

  // Show error if connection fails
  if (error) {
    console.error('Chat error:', error);
    logError(`Chat connection error: ${error}`, { userId: user?.id });
  }

  return (
    <div
      className="fixed z-50 transition-all duration-500 ease-in-out"
      style={{
        bottom: position.bottom,
        right: position.right
      }}
    >
      {/* Floating Chat Button */}
      {!isOpen && (
        <button
          onClick={() => setIsOpen(true)}
          className={`
            flex items-center justify-center w-14 h-14 rounded-full
            shadow-lg hover:shadow-xl transition-all duration-300
            focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500
            ${darkMode ? 'bg-gradient-to-r from-orange-600 to-orange-700 text-white' : 'bg-gradient-to-r from-orange-500 to-orange-600 text-white'}
            hover:scale-110 relative overflow-hidden
            ${!isConnected ? 'animate-pulse' : ''}
          `}
          aria-label={t('chat.openChat', 'Open chat')}
          role="button"
          tabIndex={0}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              setIsOpen(true);
            }
          }}
        >
          <Bot className="w-6 h-6" aria-hidden="true" />
          {unreadCount > 0 && (
            <span
              className={`
                absolute -top-2 -right-2 flex items-center justify-center
                w-6 h-6 rounded-full text-xs font-bold text-white
                ${darkMode ? 'bg-red-500' : 'bg-red-600'}
              `}
              aria-label={`${unreadCount} unread messages`}
            >
              {unreadCount > 9 ? '9+' : unreadCount}
            </span>
          )}
          <div className="absolute inset-0 rounded-full opacity-0 bg-white animate-ping"></div>
        </button>
      )}

      {/* Chat Panel */}
      {isOpen && (
        <div
          className={`
            w-80 sm:w-96 max-w-[90vw] h-[500px] sm:h-[600px] max-h-[80vh] flex flex-col rounded-2xl shadow-2xl
            ${darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}
            border ${isConnected ? (darkMode ? 'border-gray-700' : 'border-gray-200') : 'border-red-500'}
            overflow-hidden transition-all duration-300
          `}
          role="dialog"
          aria-modal="true"
          aria-label={t('chat.assistantName', 'AI Shopping Assistant')}
        >
          {/* Header */}
          <div
            className={`
              p-4 flex items-center justify-between
              ${darkMode ? 'bg-gray-900' : 'bg-gray-50'}
              border-b ${darkMode ? 'border-gray-700' : 'border-gray-200'}
            `}
          >
            <div className="flex items-center space-x-2 rtl:space-x-reverse">
              <div className="relative">
                <Bot className="w-8 h-8 text-orange-500" aria-hidden="true" />
                <div className={`absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-white dark:border-gray-800 ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} aria-label={isConnected ? t('chat.online', 'Online') : t('chat.offline', 'Offline')}></div>
              </div>
              <div>
                <h3 className="font-semibold text-lg">{t('chat.assistantName', 'AI Shopping Assistant')}</h3>
                <p className={`text-xs ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  {isConnected ? t('chat.online', 'Online') : t('chat.offline', 'Offline')}
                </p>
              </div>
            </div>
            <button
              onClick={() => setIsOpen(false)}
              className={`
                p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700
                transition-colors focus:outline-none focus:ring-2 focus:ring-orange-500
              `}
              aria-label={t('chat.closeChat', 'Close chat')}
              tabIndex={0}
            >
              <X className="w-5 h-5" aria-hidden="true" />
            </button>
          </div>

          {/* Messages Container */}
          <div
            ref={chatContainerRef}
            className="flex-1 overflow-y-auto p-4 space-y-4"
            role="log"
            aria-live="polite"
          >
            {!isConnected && (
              <div className="text-center py-2 text-sm text-orange-500">
                {t('chat.connecting', 'Connecting...')}
              </div>
            )}
            {messages.length === 0 ? (
              <div className="h-full flex flex-col items-center justify-center text-center p-4">
                <div className="mb-4 p-3 rounded-full bg-orange-100 dark:bg-orange-900/30">
                  <Bot className="w-8 h-8 text-orange-500" aria-hidden="true" />
                </div>
                <h4 className="font-medium text-lg">{t('chat.welcome', 'Welcome to AI Shopping Assistant!')}</h4>
                <p className={`text-sm mt-2 ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  {t('chat.intro', 'Ask me anything about products, get recommendations, or analyze images!')}
                </p>
              </div>
            ) : (
              messages.map((message) => (
                <ChatMessage
                  key={message.id}
                  message={message}
                  isCurrentUser={message.sender === 'user'}
                />
              ))
            )}
            {isTyping && (
              <div className="flex items-center space-x-2 rtl:space-x-reverse">
                <div className="flex-1">
                  <div className="flex items-center space-x-2 rtl:space-x-reverse mb-1">
                    <div className="bg-gray-100 dark:bg-gray-700 rounded-full p-1" aria-hidden="true">
                      <Bot className="w-4 h-4 text-gray-500 dark:text-gray-400" />
                    </div>
                    <span className="text-xs text-gray-500 dark:text-gray-400">
                      {t('chat.typing', 'AI is typing...')}
                    </span>
                  </div>
                  <div className="ml-6 flex space-x-1">
                    <div className="w-2 h-2 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce" aria-hidden="true"></div>
                    <div className="w-2 h-2 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }} aria-hidden="true"></div>
                    <div className="w-2 h-2 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }} aria-hidden="true"></div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* AI Actions Menu */}
          {showAIActions && (
            <AIActionsMenu
              onAction={handleAIAction}
              onClose={() => setShowAIActions(false)}
              darkMode={darkMode}
              t={t}
            />
          )}

          {/* Input Area */}
          <div
            className={`
              p-3 border-t ${darkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-gray-50'}
            `}
          >
            <ChatInput
              onSend={handleSendMessage}
              darkMode={darkMode}
              onToggleAIActions={() => setShowAIActions(!showAIActions)}
            />
          </div>
        </div>
      )}
    </div>
  );
};

export default FloatingChatBot;